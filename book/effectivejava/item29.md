## 아이템29. 이왕이면 제너릭 타입으로 만들라
* 아이템7의 스택코드
	* 제너릭이 절실한 강력 후보!
	* 현 상태에서의 클라이언트는 스택에서 꺼낸 객체를 형변환해야하는데, 이때 런타임 오류가 날 위험이 있따
* 일반클래스 -> 제너릭 클래스로 만드는 단계
	* 클래스 선언에 타입 매개변수를 추가
		* 타입 이름으로는 보통 E를 사용
	* 코드에 쓰인 Object를 적절한 타입 매개변수로 바꾸고 컴파일
		* 컴파일 되지 않음!
		* E와 같은 실체화 불가 타입으로는 배열을 만들 수 없다
		* 배열을 사용하는 코드를 제너릭으로 바꿀 때 해결방법
			* 제너릭 배열 생성을 금지하는 제약을 대놓고 우회
				* Object 배열로 생성 후 제너릭 배열로 형변환
				* 비검사 형변환이 확실하다면 @SuppressWarnings 로 해당 경고 숨김
				* 가독성이 좋고 코드도 짧다
				* 현업에서는 더 선호
				* 배열의 런타임 타입이 컴파일타임 타입과 달라 힙오염을 일으킴
			* elements 필드 타입을 E[]에서 Object[]로 바꿈
				* E는 실체화 불가 타입이므로 컴파일러는 런타임에 이뤄지는 형변환이 안전한지 증명할 방법이 없다
				* 직접 증명하고 경고를 숨김
				* 아이템27의 조언에 따라 비검사 형변환을 수행하는 할당문에서만 숨김
				* 힙 오염의 우려로 위 방법을 선호하기도 함
* 타입 매개변수에 제약을 두는 제너릭 타입
	* 한정적 타입 매개변수
```java
class DelayQueue<E extends Delayed> implements BlockingQueue<E>
```

### 핵심정리
* 클라에서 직접 형변환해야하는 타입보다는 제너릭 타입이 더 안전하고 쓰기 편함
* 새로운 타입을 설계할 때는 형변환 없이도 사용할 수 있어야함
* 그럴 땐 대개 제너릭으로 !!
* 기존 타입 중 제너릭이었어야 하는 부분이 있다면 제너릭 타입으로 변경

<!--stackedit_data:
eyJoaXN0b3J5IjpbMTU5NTYzNzg1OCwtMTExNjQzNjczNSwtMT
Q5ODM0MTIzN119
-->